import React, { useEffect, useRef } from "react";
import { MonacoEditor, addDiagnostics } from "@open-rpc/monaco-editor-react";
import * as monaco from "monaco-editor";
import { MethodObject, OpenrpcDocument } from "@open-rpc/meta-schema";
import useWindowSize from "@rehooks/window-size";
import openrpcDocumentToJSONRPCSchema from "../helpers/openrpcDocumentToJSONRPCSchema";

interface IProps {
  onChange?: (newValue: any) => void;
  openrpcMethodObject?: MethodObject;
  openrpcDocument?: OpenrpcDocument;
  value: any;
}

// Add type for JSON worker validation results
interface ValidationResult {
  message: string;
  severity: number;
  source: string;
  startLineNumber: number;
  startColumn: number;
  endLineNumber: number;
  endColumn: number;
}

const JSONRPCRequestEditor: React.FC<IProps> = (props) => {
  const editorRef = useRef<monaco.editor.IStandaloneCodeEditor | null>(null);
  const modelRef = useRef<monaco.editor.ITextModel | null>(null);
  const windowSize = useWindowSize();
  //  const modelUri = model.uri.toString();
    // Configure JSON language features
   // console.log("modelUri", modelUri);
  useEffect(() => {
    console.log("useEffect Rendered");

  }, []);

  useEffect(() => {
    if (editorRef.current) {
      editorRef.current.layout();
    }
  }, [windowSize]);

  useEffect(() => {
    if (!editorRef.current) {
      return;
    }
    //const model = editorRef.current.getModel();
    if(!modelRef.current) return;
    modelRef.current.setValue(props.value);

    // Register JSON language first
    /*monaco.languages.json.jsonDefaults.setModeConfiguration({
      documentFormattingEdits: true,
      documentRangeFormattingEdits: true,
      completionItems: true,
      hovers: true,
      documentSymbols: true,
      tokens: true,
      colors: true,
      foldingRanges: true,
      diagnostics: true
    });*/
    monaco.editor.setModelLanguage(modelRef.current, "json");
    


    
    
      

    // Verify schema registration
    const registeredSchemas = monaco.languages.json.jsonDefaults.diagnosticsOptions.schemas;
    console.log("Registered schemas:", registeredSchemas);

    // Check if model has the schema
    if (modelRef.current) {
      console.log("modeled");
      // Get the language service
    /*  monaco.languages.json.getWorker().then(worker => {
        worker(model.uri).then((jsonWorker: any) => {
          // Get validation results
          jsonWorker.doValidation().then((diagnostics: ValidationResult[]) => {
            console.log("JSON Validation Results:", diagnostics);
          });

          // Monitor for validation changes
          const disposable = model.onDidChangeContent(() => {
            jsonWorker.doValidation().then((validationResults: ValidationResult[]) => {
              console.log("Validation after change:", validationResults);
            });
          });

          // Cleanup on schema change
          return () => {
            disposable.dispose();
          };
        });
      });*/
      if(editorRef.current)
        console.log("editor was set for sure");
    }

    console.log("Current model markers:", monaco.editor.getModelMarkers({resource: modelRef.current?.uri}));

    // Configure editor for better autocompletion
    editorRef.current.updateOptions({
      quickSuggestions: {
        other: true,
        comments: false,
        strings: true
      },
      suggestOnTriggerCharacters: true,
      wordBasedSuggestions: "allDocuments",
      parameterHints: {
        enabled: true
      },
      snippetSuggestions: "inline",
      suggest: {
        showIcons: true,
        showStatusBar: true,
        preview: true,
        filterGraceful: true,
        showMethods: true,
        showFunctions: true,
        showConstructors: true,
        showFields: true,
        showVariables: true,
        showClasses: true,
        showStructs: true,
        showInterfaces: true,
        showModules: true,
        showProperties: true,
        showEvents: true,
        showOperators: true,
        showUnits: true,
        showValues: true,
        showConstants: true,
        showEnums: true,
        showEnumMembers: true,
        showKeywords: true,
        showWords: true,
        showColors: true,
        showFiles: true,
        showReferences: true,
        showFolders: true,
        showTypeParameters: true,
        showSnippets: true
      }
    });

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [props.openrpcDocument]);

  function handleEditorDidMount(ed: any) {
    editorRef.current = ed;
 let schema: any = {
      type: "object",
      properties: {
        jsonrpc: {
          type: "string",
          const: "2.0",
        },
        id: {
          oneOf: [
            {
              type: "string",
            },
            {
              type: "number",
            },
          ],
        },
        method: {
          type: "string",
        },
      },
    };

    if (props.openrpcDocument) {
      schema = openrpcDocumentToJSONRPCSchema(props.openrpcDocument);
    } else {
      schema = {
        additionalProperties: false,
        properties: {
          ...schema.properties,
          params: {
            oneOf: [
              { type: "array" },
              { type: "object" },
            ],
          },
        },
      };
    }

    // Configure JSON language features

    monaco.languages.json.jsonDefaults.setDiagnosticsOptions({
      validate: true,
      schemas: [{
        uri: "$foobarSchema",
        fileMatch: ["*"],
        schema
      }],
      enableSchemaRequest: true,
      allowComments: false,
    });
  }

  const handleChange = (newValue?: string) => {
    if (props.onChange) {
      props.onChange(newValue);
    }
    if(!editorRef.current) 
      {
        console.log("editor is not set");
        return;
      }
      else 
      {
        console.log("editor is set");
    const model = editorRef.current.getModel();
    const markers = monaco.editor.getModelMarkers({ resource: editorRef.current.getModel().uri });
    console.log("Markers:", markers);

    const registeredSchemas = monaco.languages.json.jsonDefaults.diagnosticsOptions.schemas;
    console.log("Registered schemas:", registeredSchemas);
      }
    

    
  };

  return (
    <MonacoEditor
      height="100%"
      width="100%"
      value={props.value}
      onMount={handleEditorDidMount}
      options={{
        minimap: {
          enabled: false,
        },
        automaticLayout: true,
        fixedOverflowWidgets: true,
      }}
      language="json"
      onChange={handleChange}
    />
  );
};

export default JSONRPCRequestEditor;
